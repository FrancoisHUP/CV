### Directory Structure ###
Directory structure:
└── francoishup-inf8810_tp2/
    ├── README.md
    ├── instructions_projet2.md
    ├── main.py
    ├── pretraitement_items.ipynb
    ├── rapport.md
    ├── requirements.txt
    └── utils/
        ├── check_neo4j_status.py
        ├── config.py
        ├── download_csv_data.py
        ├── download_raw_data.py
        ├── import_data_neo4j.py
        └── neo4j_recommender.py


### Code Content ###
================================================
File: README.md
================================================
# INF8810_TP2

Veuillez consulter notre [rapport](./rapport.md) pour les réponses aux questions de l'énoncé. Ce document détaille les étapes à suivre pour mettre en place l'environnement, télécharger les données, les importer et lancer notre système de recommendation sur Neo4J.

## 1. Installez les bibliothèques Python
```bash
$ pip install -r requirements.txt
```

## 2. Installation Neo4j

Assurez-vous d'avoir une version du logiciel [Neo4j installée](https://neo4j.com/download/) et en cours d'exécution sur votre machine. Vous devrez changer le mot de passe et nom de l'utilisateur dans le fichier ```.env``` à la racine du dossier. 

Pour tester si le logiciel est bien installé et activé :

```bash
$ python utils/check_neo4j_status.py 
```

## 3. Télécharger les données

Pour les données brutes (jeu de données original)
```bash
$ python utils/download_raw_data.py
```

Pour les données pré-traitées / données utilisées pour Neo4j ([Google Drive](https://drive.google.com/drive/folders/11onNyuwrslBDdj1rIh6C6hPV_UAbWvye?usp=sharing)) : 
```bash
$ python utils/download_csv_data.py
```

Les données doivent être enregistrées dans le dossier "data_csv/"  
```md
INF8810_TP2/
├── data_csv/
│   ├── aus_reviews.csv
│   ├── games_data_bins.csv
│   ├── users_data.csv
│   ├── users_games.csv
├── .env
```

Avec le fichier ```.env```
```
NEO4J_URI=bolt://localhost:7687
NEO4J_USERNAME=your_username
NEO4J_PASSWORD=your_password
```
 
> **_NOTE:_** Par default, le mot de passe et nom d'utilisateur sont "neo4j"

## 4. Importer les données dans Neo4j

Cette opération prend un certain temps (2h+)

```bash
$ python utils/import_data_neo4j.py
```

```
Starting data imporing process...
=== Connected as user : neo4j ===

=== File Summary ===
Games file: data_csv/games_data_bins.csv, Rows: 1854
Users file: data_csv/users_data.csv, Rows: 71504
User-Game Relationships file: data_csv/users_games.csv, Rows: 2643793
Reviews file: data_csv/aus_reviews.csv, Rows: 53533
=====================
Loading games...
Games Progress: 100%|████████████████████████████████████████████████████████████████████████████████████████████████████████████| 1854/1854 [00:04<00:00, 406.63it/s] 
Loading users...
Users Progress: 100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████| 71504/71504 [00:57<00:00, 1235.17it/s] 
Loading user-game relationships...
Relationships Progress: 100%|████████████████████████████████████████████████████████████████████████████████████████████| 2643793/2643793 [2:15:11<00:00, 325.92it/s] 
Loading reviews...
Reviews Progress: 100%|████████████████████████████████████████████████████████████████████████████████████████████████████████| 53533/53533 [02:57<00:00, 302.32it/s]

=== Sample Games ===
Game ID: 10, Name: Counter-Strike
Game ID: 50, Name: Half-Life: Opposing Force
Game ID: 70, Name: Half-Life
Game ID: 130, Name: Half-Life: Blue Shift
Game ID: 300, Name: Day of Defeat: Source

=== Sample Users ===
User ID: 76561197970982479
User ID: js41637
User ID: evcentric
User ID: Riot-Punch
User ID: doctr

=== Sample Reviews ===
User ID: Bennysaputra, Game ID: 10, Review: Cool game
User ID: 76561198040188061, Game ID: 10, Review: this game is the 1# online action game is awesome, it's better than Team fortress games and other mutiplit-player games
User ID: mayshowganmore, Game ID: 10, Review: THE BEST FPS GAME!!!!!
User ID: BestinTheWorldThund3r, Game ID: 10, Review: One of the best childhood games i have ever played! 10/10 !
User ID: apex124, Game ID: 10, Review: Que decir de este gran juego?? Comence a jugarlo alla por 2002, y he vuelto a jugarlo ahora, y me satisface tanto como antes.   

=== Metrics Report ===
Games added: 1854
Users added: 71504
Relationships added: 2643793
Reviews added: 53533
======================
Data successfully loaded into Neo4j!
```

## 5. Lancer le logiciel de recommendation 

Lister des utilisateurs au hasard:
```
python main.py --list_users --limit 5
```

Obtenir les informations d'un utilisateur :
```bash
python main.py --user_info 76561197970982479
```

Filtrage collaboratif (Collaborative filtering recommendations):
```bash
python main.py --type collaborative --user_id 76561197970982479 --limit 5
```

Filtrage basé sur le contenu (Content-based recommendations):
```bash
python main.py --type content --user_id 76561197970982479 --limit 5
```

Hybride (Hybrid recommendations):
```bash
python main.py --type hybrid --user_id 76561197970982479 --limit 5
```

Recommandation avec les percentilles (TODO):
```bash
python main.py --type bins --user_id 76561197970982479 --bin_threshold 2 --limit 5
```

================================================
File: instructions_projet2.md
================================================
# Instructions Projet 2

Préparé par Jean-Francois Rajotte

Automne 2024

## Objectif
L'objectif de ce projet est de développer un système de recommandation à partir des outils de base Neo4j.

## Consignes de remise du travail
Le travail doit être remis au plus tard le **8 décembre (23h55)**.

**Important:** Pour chaque jour de retard, vous perdrez 5% de votre note.
Après 7 jours, votre résultat sera 0.
Pas de période de grâce une fois le délai écoulé.

Vous pouvez travailler en équipe de 3 personnes maximum.


## Critères d'évaluation
Ce TP est noté sur 30 points et compte pour 30% de votre note finale.

Vous devez vous assurez de donner des instructions complètes: quelles commandes envoyer, où mettre les fichiers...

* Remise sur Moodle
  * un rapport Markdown ou Word incluant:
    * le nom des membres de votre équipe
    * chacune des étapes décrites ci-dessous, clairement identifiées par un titre.
    * les réponses aux questions
  * Autre(s) fichier(s) (e.g. script de nettoyage python) utilisés pour le projet. 
* Votre rapport doit donner toutes les commandes pour reproduire votre travail avec *copier-coller*.
* Aucune librairie de recommandation ou de calcul de similarité ne peut être utilisée pour le projet.

### Originalité
Vous serez évalué sur la consistance de vos traitements et la complétude et les détails dans votre rapport par rapport aux spécifications ainsi que l’optimalité et la qualité du code.
Il ne faut pas vous limiter à reprendre les exemples du cours. Dans le cas contraire, vous serez pénalisé.
En effet, vous serez évalué sur l’originalité de votre travail.

**Le non-respect des modalités sera pénalisé.**

* La présentation en général et les fichiers remis: 3/30
    * Clarté du travail en général
    * Les tâches des sections "**Ce qui vous devez faire**" doivent être identifiées et chaque question doit être répondu clairement.
    * Les commandes pour chaque étapes doivent être clairement identifiées.

* Implémentation, discussion: 27/30

## Partie 1 : Données (5 points)

Identifiez, analysez et choisissez vos sources de données (Voir section Projet 2 *Répertoire des
datasets des systèmes de recommandation (Ref. Julian McAuley, UCSD)* dans votre site
de cours Moodle ou d’autres datasets de votre choix).

**Ce qui vous devez faire**:
* Question: Quel est l'origine des données (lien, source)?
* Question : Quel est le contexte du jeu de données, exemple: vente en ligne?
* Vérifiez vos données, effectuez un prétraitement (en Python) si nécessaire (pas besoin
de les faire sur Neo4J).
* Documenter les différentes étapes dans votre rapport dans une **section prétraitement des données**.

## Partie 2 : Chargement dans neo4j (10 points)

* Question : Quelles données chargez-vous dans neo4j?
* Question : Faites-vous des traitements/modifications lors du chargement?
* Chargez vos données en utilisant uniquement NEO4J
* Incluez vos requêtes et décrivez vos étapes dans votre rapport.


## Partie 3 : Recommandation (12 points)
Créer une un système de recommandation.
Seulement à titre d’exemple (ça dépandéra naturellement des données choisies et le domaine d’application), recommandez un ensemble de chansons à un utilisateur sur la base d’une chanson (donnée en entrée) que ce même utilisateur a aimé. 
En d’autres termes, l’utilisateur Reiaz a aimé la chanson C1, votre solution va recommander à l’utilisateur Reiaz les chansons C2, C3 et C4 que potentiellement il va aimer. 
Utilisez les exemples de requêtes et de types d’approches de recommandation (basée contenu, filtrage collaboratif et hybride) étudiés en classe pour créer votre propre requête de recommandation (Votre propre requête – pas une reprise des exemples du cours).

**Ce qui vous devez faire**:
* Question : Quelle recommandation proposez-vous?
  * Qu'est-ce qui est recommandé?
  * À qui ou quoi faites-vous cette recommandation?
* Créez une requête pour faire une recommandation en fonction de votre source de données.
* Décrivez en détail l’approche de votre requête de recommandation et incluez votre code dans votre rapport.


================================================
File: main.py
================================================
import argparse
from utils.config import load_env
from utils.neo4j_recommender import RecommenderSystem
import json

def json_format(results) :
    print("\nCollaborative Filtering Recommendations:")
    print(json.dumps(results, indent=4))


def list_random_users(recommender, limit=5):
    """List random users from the database."""
    print("\nListing Random Users:")
    users = recommender.list_users(limit)
    for user in users:
        print(f"- User ID: {user['user_id']}, Items Count: {user.get('items_count', 'N/A')}")


def get_user_info(recommender, user_id):
    """Fetch detailed information about a specific user."""
    print(f"\nFetching Information for User ID: {user_id}")
    user_info = recommender.get_user_info(user_id)
    if not user_info:
        print(f"No information found for User ID: {user_id}")
    else:
        print("User Information:")
        print(f"- User ID: {user_info['user_id']}")
        print(f"- Items Count: {user_info.get('items_count', 'N/A')}")
        print(f"- Played Games: {user_info.get('played_games', 'N/A')}")
        print(f"- Total Playtime: {user_info.get('total_playtime', 'N/A')} hours\n")
        print("Games Played (sorted by playtime):")

        for game in user_info.get("games", []):
            # Determine Player Bin
            playtime = game["playtime"] or 0
            max_bins = game["max_bin"]
            player_bin = 1
            player_bin = next((i + 1 for i, max_value in enumerate(max_bins) if playtime <= max_value), len(max_bins) + 1)

            print(f"  [{game['rank']}] {game['name']} (ID: {game['game_id']})")
            print(
                f"      Playtime: {playtime}h | Player Count: {game['player_count']} | Max Bins: {max_bins} | Player Bin: {player_bin}"
            )
            print(f"      Review: {game['review'] or 'No review'}")
        print("\n--- End of User Information ---")


def has_relevant_arguments(args):
    """Check if relevant arguments (beyond defaults) are provided."""
    return any([args.list_users, args.user_info, args.type, args.user_id])


def run():
    # Load environment variables
    env_config = load_env()
    DATABASE_URI = env_config["uri"]
    USERNAME = env_config["username"]
    PASSWORD = env_config["password"]

    # Initialize the recommender system
    recommender = RecommenderSystem(uri=DATABASE_URI, user=USERNAME, password=PASSWORD)

    parser = argparse.ArgumentParser(
        description="Recommendation System CLI",
        usage="""
        python main.py [OPTIONS]

        Options:
          --list_users                     List random users from the database.
          --user_info USER_ID              Fetch detailed information about a specific user.
          --type {collaborative,content,hybrid,bins} 
                                           Specify the type of recommendation.
          --user_id USER_ID                Specify the user ID for recommendations.
          --limit NUMBER                   Limit the number of results (default: 5).
          --bin_threshold NUMBER           Threshold for bin-based recommendations (default: 1).

        Examples:
          List random users:
            python main.py --list_users --limit 5

          Get user info:
            python main.py --user_info 76561197970982479

          Collaborative filtering recommendations:
            python main.py --type collaborative --user_id 76561197970982479 --limit 5

          Content-based recommendations:
            python main.py --type content --user_id 76561197970982479 --limit 5

          Hybrid recommendations:
            python main.py --type hybrid --user_id 76561197970982479 --limit 5

          Recommendations using bins:
            python main.py --type bins --user_id 76561197970982479 --bin_threshold 2 --limit 5
        """
    )
    parser.add_argument("--user_id", type=str, help="Specify the user ID for recommendations")
    parser.add_argument("--type", type=str, choices=["collaborative", "content", "hybrid", "bins"],
                        help="Type of recommendation (collaborative, content, hybrid, bins)")
    parser.add_argument("--list_users", action="store_true", help="List random users")
    parser.add_argument("--user_info", type=str, help="Fetch information about a specific user")
    parser.add_argument("--limit", type=int, default=5, help="Limit the number of recommendations or users")
    parser.add_argument("--bin_threshold", type=int, default=1, help="Threshold for bin-based recommendations")

    args = parser.parse_args()

    # Check for relevant arguments
    if not has_relevant_arguments(args):
        parser.print_help()
        return

    try:
        if args.list_users:
            list_random_users(recommender, limit=args.limit)

        elif args.user_info:
            get_user_info(recommender, args.user_info)

        elif args.type and args.user_id:
            user_id = args.user_id
            rec_type = args.type.lower()

            if rec_type == "collaborative":
                print("\nCollaborative Filtering Recommendations:")
                print(json.dumps(recommender.collaborative_filtering(user_id, top_n=args.limit), indent=4))

            elif rec_type == "content":
                print("\nContent-Based Filtering Recommendations:")
                print(json.dumps(recommender.content_based_filtering(user_id, top_n=args.limit), indent=4))

            elif rec_type == "hybrid":
                print("\nHybrid Recommendations:")
                print(json.dumps(recommender.hybrid_recommendation(user_id, top_n=args.limit), indent=4))

            elif rec_type == "bins":
                print("\nRecommendations Using Bins:")
                # To be rework !
                # print(json.dumps(recommender.recommend_by_bins(user_id, bin_threshold=args.bin_threshold, top_n=args.limit), indent=4))

            else:
                print(f"Unknown recommendation type: {rec_type}")

    finally:
        recommender.close()


if __name__ == "__main__":
    run()


================================================
File: rapport.md
================================================
## Projet réalisé par:
* Guillaume Carignan CARG29099504
* Etienne Comtois COME17029800
* François Huppé-Marcoux HUPF10049509

## Partie 1 : Données 

### Question: Quel est l'origine des données (lien, source)?
Les données que nous avons choisies d'utiliser sont celles des ensembles de données "[Version 1: Review Data](https://cseweb.ucsd.edu/~jmcauley/datasets.html#steam_data)" (données de revues de jeux) et "[Version 1: User and Item Data](https://cseweb.ucsd.edu/~jmcauley/datasets.html#steam_data)" (données des jeux de Steam). Les revues et les données de jeux sont d'origine d'Australie.
Un plus grand ensemble de données de revue de jeux existe (version 2), mais cet ensemble de donnéees n'a pas d'appréciation pour les revues (positive ou négative). Nous aurions pu prétraiter les revues avec une [analyse de sentiment](https://www.kaggle.com/code/tea713/steam-reviews-sentimental-analysis). Par contre, plusieurs revues peuvent être ambiguës et donnent peu d'indices sur la recommendation du jeu. Par exemple, des revues comme :
<pre>
잼꾸르잼
</pre>
<pre>
#DEEP
</pre>
<pre>
____?Sexy?Sexy ___?Sexy?Sexy?R ___?...
</pre>
sont difficiles à classer. Par soucis de simplicité, nous avons décidé d'utiliser que les données provenant d'Australie.  


### Quel est le contexte du jeu de données?
Les données sont celles des revues Steam comme celle-ci:![steam review](Sample_review.png "Steam Review")

La photo et le nom d'utilisateur a été enlevé mais est disponible dans le dataset que nous utiliserons. Ces revues sont faites sur la page du magasin de Steam qui fait de la vente en ligne  de jeux dématerialisés, de logiciels, de bandes son originales et de quelques produits physiques comme la Steam Deck et de matériel de réalité virtuelle. Tous les produits vendus sur la plateforme ont des revues ainsi qu'une note en pourcentage (bonne/mauvaises revues * 100) qui détermine son appréciation. Cela peut varier entre *Overwhelmingly Negative*, *Very Negative*, *Mostly Negative*, *Negative*, *Mixed*, *Mostly Positive*, *Positive*,  *Very Positive* et finalement *Overwhelmingly Positive*.
Les pondérations sont les suivantes:

```
%score  |   #reviews   |  rating  |   confidence

95 - 100 | 500+ reviews | positive | overwhelmingly
85 - 100 |  50+ reviews | positive | very
80 - 100 |  10+ reviews | positive | -
70 -  79 |  10+ reviews | positive | mostly
40 -  69 |  10+ reviews | mixed    | -
20 -  39 |  10+ reviews | negative | mostly
 0 -  19 |  10+ reviews | negative | -
 0 -  19 |  50+ reviews | negative | very
 0 -  19 | 500+ reviews | negative | overwhelmingly
 
 ```




### Prétraitement des données
Le prétraitement ainsi que la vérification des données se trouve dans [pretraitement_items.ipynb](pretraitement_items.ipynb). Pour collecter les informations que nous voulions, il a fallu nettoyer les sources de données et nous avons débuté par importer les fichiers JSON comme dictionnaires python puis les convertir en fichiers CSV pour utiliser avec Neo4J. Nos fichiers qui seront créés à partir des données de ``australian_users_items.json`` sont: *Games*, *User Lib* et *User Data*. Il est à noter que les détails de l'implémentation se retrouve dans [pretraitement_items.ipynb](pretraitement_items.ipynb).

#### Games
Pour ce fichier de prétraiement nous nous intéressont aux clées suivantes: `game_id` (id du jeu dans la base de données Steam), `name` (nom du jeu), `temps_total_joué` (temps total joué par tous les utilisateurs qui possèdent ce jeu) et `nombre_joueurs_joué`(nombre de joueurs différents ayant ce jeu et ayant joué). Il est à préciser que nous itérons sur tous les joueurs et ne comptabilisons que les joueurs ayant un temps de jeu supérieur à 0. Nous convertissons par la suite le dictionnaire en dataframe pour la sauvegarde en CSV. Nous simplifions également le temps de jeu en heures (il est normalement en minutes) pour réduire la taille du fichier et parce que la perte de temps de jeu dans l'étape d'arrondissement (1 minute jouée devient 1h, par exemple 61 minutes devient 2 heures) est dérisoire lorsque l'on parle de milliers d'heures comme c'est le cas pour `Counter-Strike: Global Offensive` avec ses `13086405` heures de jeu. Nous calculons aussi le temps médian d'un joueur sur chaque jeu afin de potentiellement utiliser cette mesure par la suite. Le tout est enregistré dans `./data_csv/games_data.csv` sur le Google Drive.

#### User Lib
Pour cette section nous nous intéressons à chaque paire *Joueur-Jeu* et comme pour *Games*, nous convertissons le temps de jeu en heures. Les clées qui nous intéressent cette fois sont: `user_id` (id du joueur), `game_id` (id du jeu), `playtime (hours)` (nombre d'heures que ce joueur a sur le jeu) et `active (bool)` (le joueur as-t-il joué au jeu dans les deux dernières semaine?). Suite aux calculs le fichier résultant est le `./data_csv/users_data.csv` sur le Google Drive.

#### User Data
Pour le *User Data*, nous voulions définir le joueur ou utilisateur avec ces clées: `user_id`, `games_count` (nombre de jeux possédés), `total_playtime` (temps de jeu total sur tous les jeux) et `most_played_game_id` (à quel jeu cet utilisateur as-t-il le plus joué). 

#### Calcul des Bins
Nous voulions nous donner une idée de la répartition du temps de jeu parmi la population de joueur et c'est le but des *Bins*. Il s'agit simplement d'une division en 5 de la population des joueurs et de leur temps de jeu moyen afin de pouvoir se faire une idée sur la communauté du jeu. Est-il abandonné rapidement ou possède une communauté de joueurs assidus? Nous trouvions l'exercice intéressant et potentiellement utile plus tard. Suite aux calculs le résultat est enregistré sur `./data_csv/games_data_bins.csv` dans le Google Drive.

#### Réduction des données
Nous avons décidé de réduire la taille de nos données afin de ne pas faire de traitements inutiles et par contraintes de stockage.
##### Games 
Pour cela nous avons retiré de la liste des jeux tous ceux qui ont moins de 100 propirétaires ainsi que les jeux dont le temps de jeu médian est plus petit ou égal à une heure (convertie). Cela vient éliminer 9124 jeux qui n'ont pas d'intérêt pour notre système. N'importe qui peut créer son jeu sur Steam moyennant une somme de 100$ et beaucoup de ces projets sont abandonnés. Nous sommes confiant que ces jeux ne nous serons pas utiles. 
##### User Lib
Nous avons les jeux concernés par l'étape précédente de *User Lib* même si l'utilisateur y a déjà joué.
##### User Reviews
Nous avons retiré les mauvais jeux des reviews de notre source de données afin de garder uniquement les reviews des jeux que nous allons utiliser.


## Partie 2 : Chargement dans neo4j 

### À NOTER
Toutes les instructions qui concernent nos opérations Neo4J se trouvent dans notre [README.md](README.md).

Le fichier [import_data_neo4j.py](import_data_neo4j.py) est le responsable du chargement dans Neo4J
### Quelles données chargez-vous dans neo4j?

Nous chargeons les 4 fichiers obtenus lors du prétraitement : 
* ``GAMES_FILE =  "data_csv/games_data_bins.csv"``
* ``USER_GAME_FILE = "data_csv/users_games.csv"``
* ``REVIEWS_FILE = "data_csv/aus_reviews.csv"``
* ``USER_FILE = "data_csv/users_data.csv"``


### Faites-vous des traitements/modifications lors du chargement?
Oui nous établissons des contraintes d'unicité pour les jeux et les utilisateurs. 

### Étapes suivies

#### Éxécution globale

L'éxécution de l'importation en entier se fait par le biais de cette commande (voir notre [README.md](README.md)):
```bash
$ python utils/import_data_neo4j.py
```

#### Métriques
Nous définissons des métriques qui seront utiles pour notre usage: `games_added`, `users_added`, `relationships_added` et `reviews_added`. Il est important de noter que les requêtes qui suivront dans les prochaines sections n'inclueront pas les métriques et se trouvent à la fin de celles-ci dans leurs fonction respectives. Voir [./utils/import_data_neo4j.py](./utils/import_data_neo4j.py) pour plus de précisions.

#### Chargement des jeux
La fonction `load_games` permet de charger les jeux à partir de `GAMES_FILE` et la requête est la suivante: 
```
MERGE (g:Game {game_id: $game_id})
    ON CREATE SET 
        g.name = $name,
        g.time_played = toInteger($time_played),
        g.player_count = toInteger($player_count),
        g.median_time_played = toInteger($median_time_played),
        g.max_bin_1 = toInteger($max_bin_1),
        g.max_bin_2 = toInteger($max_bin_2),
        g.max_bin_3 = toInteger($max_bin_3),
        g.max_bin_4 = toInteger($max_bin_4),
        g.max_bin_5 = toInteger($max_bin_5)
```
Nous avons les champs suivants: ``name`` (nom du jeu), ``time_played`` (temps de jeu de tous les joueurs), ``player_count`` (nombre de joueurs), ``median_time_played`` (temps de jeu médian), ``max_bin_x`` (heures de jeu du top 20% des joueurs). Si le jeu existe déjà le noeud n'est pas recréé.

#### Chargement des utilisateurs
Comme pour les jeux les utilisateurs ont leurs informations importées dans Neo4j mais par le biais du fichier `USERS_FILE` dans la fonction `load_users` et voici la requête:
```
MERGE (u:User {user_id: $user_id})
    ON CREATE SET 
        u.items_count = toInteger($items_count),
        u.played_games = toInteger($played_games),
        u.total_playtime = toInteger($total_playtime),
        u.most_played_game_id = $most_played_game_id
```
Nous avons les champs suivants: ``items_count`` (nombre de jeux possédés par le joueur), ``played_games`` (jeux dont le joueur a un temps de jeu positif), ``total_playtime`` (temps de jeu total) et ``most_played_game_id`` (jeu auquel il a le plus joué).

#### Chargement des relations Joueur-Jeu

La fonction `load_user_game_relationships` utilise le fichier `USER_GAME_FILE` et a pour but de modéliser les relations entre ces deux concepts. Les deux attributs qui seront établis dans cette étape sont: `playtime` et `active` qui sont des champs du fichier source grâce au prétraitement. Voici la requête:

```
MERGE (u:User {user_id: $user_id})
MERGE (g:Game {game_id: $game_id})
MERGE (u)-[r:PLAYS]->(g)
ON CREATE SET r.playtime = toInteger($playtime),
            r.active = $active
```
#### Chargement des avis (reviews)

La fonction `load_reviews` utilise comme paramètre le fichier `REVIEWS_FILE` et les champs résultants sont: `funny` (combien d'utilisateurs on trouvé l'avis amusant), `posted` (date de l'avis), `last_edited` (date de la dernière modification de l'avis), `helpful` (combien d'utilisateurs ont trouvé que l'avis était utile), `recommend` (indique s'il s'agit ou non d'une recommendation/avis positif) et `review` (le texte de l'avis). Voici la requête:
```
MERGE (u:User {user_id: $user_id})
MERGE (g:Game {game_id: $item_id})
MERGE (u)-[r:REVIEWS {funny: $funny, posted: $posted, 
                        last_edited: $last_edited, helpful: $helpful, 
                        recommend: $recommend, review: $review}]->(g)
```

## Partie 3 : Recommandation
Le fichier [./utils/neo4j_recommender.py](./utils/neo4j_recommender.py) contient tout le code de nos recommendations.

Pour cette section, nous allons utiliser un utilisateur pour illustrer les recherches dans Néo4j. L'utilisateur ```76561197970982479``` sera notre cobaye pour les expérimentations. Pour obtenir plus d'informations sur les habitudes de cet utilisateur, nous pouvons exécuter la commande suivante :

```bash
python main.py --user_info 76561197970982479
```

<pre>
Fetching Information for User ID: 76561197970982479
User Information:
- User ID: 76561197970982479
- Items Count: 277
- Played Games: 198
- Total Playtime: 3335 hours

Games Played (sorted by playtime):
  [1] Counter-Strike: Global Offensive (ID: 730)
      Playtime: 393h | Player Count: 43279 | Max Bins: [13, 54, 201, 530, 6272] | Player Bin: 4
      Review: No review
  [2] Rising Storm/Red Orchestra 2 Multiplayer (ID: 35450)
      Playtime: 237h | Player Count: 6138 | Max Bins: [0, 1, 4, 17, 1874] | Player Bin: 5
      Review: No review
  [3] Sid Meier's Civilization V (ID: 8930)
      Playtime: 173h | Player Count: 14279 | Max Bins: [4, 20, 50, 120, 7091] | Player Bin: 5
      Review: No review
  [4] Killing Floor (ID: 1250)
      Playtime: 167h | Player Count: 13286 | Max Bins: [2, 7, 16, 41, 6115] | Player Bin: 5
      Review: Simple yet with great replayability. In my opinion does "zombie" hordes and team work better than left 4 dead plus has a global leveling system. Alot of down to earth "zombie" splattering fun for the whole family. Amazed this sort of FPS is so rare.     
  [5] Killing Floor 2 (ID: 232090)
      Playtime: 109h | Player Count: 4095 | Max Bins: [3, 8, 17, 37, 1309] | Player Bin: 5
      Review: No review
  [...]    
  [167] Evolve Stage 2 (ID: 273350)
      Playtime: 1h | Player Count: 6373 | Max Bins: [0, 1, 3, 10, 1788] | Player Bin: 2
      Review: No review

--- End of User Information ---
</pre>

> **_NOTE:_** La différence entre le ```Items Count: 277``` et le dernier jeu identifié à la position ```[167]``` est due au prétraitement. Nous avons retiré les jeux ayant moins d'une heure de jeu et moins de 100 utilisateurs. Nous supposons que les 110 jeux manquants ont été supprimés lors du prétraitement.  
 
### Quelle recommandation proposez-vous?
Nous proposons trois recommendations: 

#### Recommendation des jeux basés sur le filtrage collaboratif.

Le but de cette requête est de trouver des utilisateurs similaires en termes de jeux, puis de recommander des jeux qu'ils ont appréciés. La requête prend un user_id en entrée et retourne une liste de jeux ainsi que la métrique de similarité.

Voici notre requête:

```
    MATCH (target:User {user_id: $user_id})-[:PLAYS]->(g:Game)<-[:PLAYS]-(similar:User)
    WITH target, similar, COUNT(g) AS shared_games
    ORDER BY shared_games DESC
    LIMIT 10
    MATCH (similar)-[:PLAYS]->(recommended:Game)
    WHERE NOT (target)-[:PLAYS]->(recommended)
    RETURN recommended.game_id AS game_id, recommended.name AS name, COUNT(*) AS popularity
    ORDER BY popularity DESC, recommended.name
    LIMIT $top_n
```
La requête suit ces étapes :
* Correspondre à l'utilisateur cible et trouver les jeux auxquels il a joué.
* Identifier les utilisateurs similaires ayant joué aux mêmes jeux et compter les jeux partagés.
* Trier les utilisateurs similaires par nombre de jeux partagés.
* Limiter le nombre d'utilisateurs similaires (pour des raisons de performance).
* Trouver les jeux joués par les utilisateurs similaires.
* Exclure les jeux auxquels l'utilisateur cible a déjà joué.
* Retourner les jeux recommandés avec leur popularité et leurs noms.
* La popularité est calculée comme le nombre d'utilisateurs similaires ayant joué au jeu recommandé.
* Trier par popularité puis par ordre alphabétique.
* Limiter le nombre de recommandations.

Voici l'execusion pour l'utilisateur ```76561197970982479``` : 
```bash
python main.py --type collaborative --user_id 76561197970982479 --limit 5
```
<pre>
Collaborative Filtering Recommendations:
[
    {
        "game_id": "211420",
        "name": "Dark Souls: Prepare to Die Edition",
        "popularity": 10
    },
    {
        "game_id": "219150",
        "name": "Hotline Miami",
        "popularity": 10
    },
    {
        "game_id": "204100",
        "name": "Max Payne 3",
        "popularity": 10
    },
    {
        "game_id": "233130",
        "name": "Shadow Warrior",
        "popularity": 10
    },
    {
        "game_id": "202170",
        "name": "Sleeping Dogs\u2122",
        "popularity": 10
    }
]
</pre> 
#### Recommendation des jeux basés sur les habitudes de jeu de l'utilisateur

Le but de cette requête est d'identifier des jeux similaires à ceux déjà joués par l'utilisateur cible, en analysant ses habitudes de jeu avec des métriques telles que le temps médian de jeu et le nombre moyen de joueurs. En prenant un user_id en entrée, la requête calcule les moyennes de ces métriques pour l'utilisateur, filtre les jeux non joués en fonction de leur proximité avec ces moyennes, et retourne une liste de recommandations triées selon leur pertinence.

Voici notre requête:
```
MATCH (target:User {user_id: $user_id})-[:PLAYS]->(g:Game)
WITH target, avg(g.median_time_played) AS user_avg_time, avg(g.player_count) AS user_avg_players
MATCH (similar:Game)
WHERE NOT (target)-[:PLAYS]->(similar)
AND ABS(similar.median_time_played - user_avg_time) < 10
AND ABS(similar.player_count - user_avg_players) < 100
RETURN similar.game_id AS game_id, similar.name AS name,
    ABS(similar.median_time_played - user_avg_time) AS time_diff,
    ABS(similar.player_count - user_avg_players) AS player_diff
ORDER BY time_diff, player_diff
LIMIT $top_n
```

* Trouver l'utilisateur cible.
* Rechercher les jeux auxquels cet utilisateur a joué.
* Calculer la moyenne du temps médian de jeu (``user_avg_time``) et le nombre moyen de joueurs (``user_avg_players``) pour les jeux joués par l'utilisateur cible.
* Trouver les jeux similaires auxquels l'utilisateur cible n'a pas encore joué.
* Filtrer les jeux similaires pour s'assurer que :
    * La différence entre le temps médian de jeu du jeu similaire et la moyenne du temps de jeu de l'utilisateur cible est inférieure à 10.
    * La différence entre le nombre de joueurs du jeu similaire et la moyenne des joueurs de l'utilisateur cible est inférieure à 100.
* Retourner les recommandations de jeux similaires
* Trier les jeux similaires par différence de temps de jeu en ordre croissant, puis par différence de nombre de joueurs en ordre croissant.
* Limiter le nombre de recommandations retournées à une valeur donnée (``$top_n``).

Voici l'execusion pour l'utilisateur ```76561197970982479``` : 
```bash
$ python main.py --type content --user_id 76561197970982479 --limit 5
```
<pre>
Content-Based Filtering Recommendations:
[
    {
        "game_id": "239820",
        "name": "Game Dev Tycoon",
        "time_diff": 2.2395209580838316,
        "player_diff": 93.95209580838127
    },
    {
        "game_id": "239220",
        "name": "The Mighty Quest For Epic Loot",
        "time_diff": 5.239520958083832,
        "player_diff": 18.047904191618727
    },
    {
        "game_id": "236110",
        "name": "Dungeon Defenders II",
        "time_diff": 6.239520958083832,
        "player_diff": 33.95209580838127
    },
    {
        "game_id": "113020",
        "name": "Monaco",
        "time_diff": 7.239520958083832,
        "player_diff": 91.04790419161873
    }
]
</pre>

#### Recommendation hybride
Il s'agit d'un mélange entre les deux solutions précédentes. Cette approche permet de trouver les jeux auxquels des utilisateurs ayant les mêmes intérêts jouent PUIS de filtrer ces résultats pour augmenter la pertinence. Voici notre requête: 
```
MATCH (target:User {user_id: $user_id})-[:PLAYS]->(g:Game)
WITH target, avg(g.median_time_played) AS user_avg_time, avg(g.player_count) AS user_avg_players
MATCH (target)-[:PLAYS]->(g:Game)<-[:PLAYS]-(similar:User)
WITH target, user_avg_time, user_avg_players, similar, COUNT(g) AS shared_games
ORDER BY shared_games DESC
LIMIT 10
MATCH (similar)-[:PLAYS]->(recommended:Game)
WHERE NOT (target)-[:PLAYS]->(recommended)
AND ABS(recommended.median_time_played - user_avg_time) < 10
AND ABS(recommended.player_count - user_avg_players) < 100
RETURN recommended.game_id AS game_id, recommended.name AS name, 
    COUNT(*) AS popularity, 
    ABS(recommended.median_time_played - user_avg_time) AS time_diff, 
    ABS(recommended.player_count - user_avg_players) AS player_diff
ORDER BY popularity DESC, time_diff ASC, player_diff ASC
LIMIT $top_n
```
* Trouver l'utilisateur cible.
* Rechercher les jeux auxquels cet utilisateur a joué.
* Calculer la moyenne du temps médian de jeu ``user_avg_time`` et le nombre moyen de joueurs ``user_avg_players`` pour les jeux joués par l'utilisateur cible.
* Identification des utilisateurs similaires :
* Trouver les utilisateurs similaires qui ont joué aux mêmes jeux que l'utilisateur cible.
* Compter le nombre de jeux partagés avec ces utilisateurs similaires (``shared_games``).
* Trier les utilisateurs similaires par le nombre de jeux partagés, en ordre décroissant.
* Limiter la liste aux 10 utilisateurs similaires les plus proches (pour des raisons de performance).
* Trouver les jeux joués par les utilisateurs similaires qui ne sont pas encore joués par l'utilisateur cible.
* Filtrer les jeux recommandés pour s'assurer que :

    * La différence entre le temps médian de jeu du jeu recommandé et la moyenne du temps de jeu de l'utilisateur cible est inférieure à 10.

    * La différence entre le nombre de joueurs du jeu recommandé et la moyenne des joueurs de l'utilisateur cible est inférieure à 100.
* Retourner les jeux recommandés.
* Trier les jeux recommandés par popularité en ordre décroissant, puis par différence de temps de jeu en ordre croissant, et enfin par différence de nombre de joueurs en ordre croissant.

* Limiter le nombre de recommandations retournées à une valeur donnée (``$top_n``).

Voici l'execusion pour l'utilisateur ```76561197970982479``` : 
```bash
$ python main.py --type hybrid --user_id 76561197970982479 --limit 5
```
<pre>
Hybrid Recommendations:
[
    {
        "game_id": "239820",
        "name": "Game Dev Tycoon",
        "popularity": 9,
        "time_diff": 2.2395209580838316,
        "player_diff": 93.95209580838127
    },
    {
        "game_id": "113020",
        "name": "Monaco",
        "popularity": 8,
        "time_diff": 7.239520958083832,
        "player_diff": 91.04790419161873
    },
    {
        "game_id": "236110",
        "name": "Dungeon Defenders II",
        "popularity": 4,
        "time_diff": 6.239520958083832,
        "player_diff": 33.95209580838127
    },
    {
        "game_id": "239220",
        "name": "The Mighty Quest For Epic Loot",
        "popularity": 3,
        "time_diff": 5.239520958083832,
        "player_diff": 18.047904191618727
    }
]
</pre>


================================================
File: requirements.txt
================================================
requests
python-dotenv
neo4j
tqdm

================================================
File: utils/check_neo4j_status.py
================================================
from neo4j import GraphDatabase
from config import load_env  

# Load environment variables from the .env file
load_env()

# Load environment variables
env_config = load_env()
DATABASE_URI = env_config["uri"]
USERNAME = env_config["username"]
PASSWORD = env_config["password"]

# Connect to the database
driver = GraphDatabase.driver(DATABASE_URI, auth=(USERNAME, PASSWORD))

def test_connection():
    with driver.session() as session:
        result = session.run("RETURN 'Connection Successful!' AS message")
        print(result.single()["message"])

test_connection()
driver.close()


================================================
File: utils/config.py
================================================
import os
from dotenv import load_dotenv

def load_env():
    """Load environment variables from the .env file."""
    # Clear existing env variables for Neo4j connection (optional)
    os.environ.pop("NEO4J_URI", None)
    os.environ.pop("NEO4J_USERNAME", None)
    os.environ.pop("NEO4J_PASSWORD", None)
    
    # Load environment variables from the .env file
    load_dotenv()
    
    # Return Neo4j configuration
    return {
        "uri": os.getenv("NEO4J_URI"),
        "username": os.getenv("NEO4J_USERNAME"),
        "password": os.getenv("NEO4J_PASSWORD"),
    }

================================================
File: utils/download_csv_data.py
================================================
import requests
import gzip
import shutil
import os

# URLs to download files
users_games="https://drive.usercontent.google.com/download?id=1hRLeEYdTVhZrCnk21ZOdE-Lg6CPqUrfr&export=download&authuser=0&confirm=t&uuid=f0a8a4ff-8bd5-4b7d-b0d2-5dc93ef288d0&at=AENtkXYDy9IDqO9t0KxXi9hq51dG:1732900404333"
games_data_bins="https://drive.usercontent.google.com/download?id=1F831wIF1-kfBotke1l6oA-FdbaIqDOo4&export=download&authuser=0&confirm=t&uuid=138f6b8c-b486-4653-8287-69673f107f65&at=AENtkXYzYTcbIo5cw6yHnEu4qTp4:1732900466945"
aus_reviews="https://drive.usercontent.google.com/download?id=1IneVMe_-dYxfDZDtaH3rgQFV0wAwq1ow&export=download&authuser=0&confirm=t&uuid=3af45070-d53d-4250-ab9b-09e258f77ae6&at=AENtkXbK_QfWsfp98NUX1PpIHhf5:1732900505238"
users_data="https://drive.usercontent.google.com/download?id=1LoaDJDZzugQt7kk7jnnj8-NKa6IjH45x&export=download&authuser=0&confirm=t&uuid=7e98bcf5-0c24-4945-a4fd-0241f925a1a2&at=AENtkXYwDPrP-AWJeZmwiInKlO2C:1732900542349"

# Directory to store data
data_folder = "data_csv"

# Ensure the data/ folder exists
os.makedirs(data_folder, exist_ok=True)

# Filenames for extracted files
users_games_file = os.path.join(data_folder, "users_games.csv")
games_data_bins_file = os.path.join(data_folder, "games_data_bins.csv")
aus_reviews_file = os.path.join(data_folder, "aus_reviews.csv")
users_data_file = os.path.join(data_folder, "users_data.csv")

def download_file(url, output_path):
    print(f"Downloading {url}...")
    response = requests.get(url, stream=True)
    if response.status_code == 200:
        with open(output_path, 'wb') as file:
            shutil.copyfileobj(response.raw, file)
        print(f"Downloaded {output_path}.")
    else:
        print(f"Failed to download {url}. Status code: {response.status_code}")

# Download the files into the data/ folder
download_file(users_games, users_games_file)
download_file(games_data_bins, games_data_bins_file)
download_file(aus_reviews, aus_reviews_file)
download_file(users_data, users_data_file)

================================================
File: utils/download_raw_data.py
================================================
import requests
import gzip
import shutil
import os

# URLs to download files
reviews_url = "https://datarepo.eng.ucsd.edu/mcauley_group/data/steam/australian_user_reviews.json.gz"
items_url = "https://datarepo.eng.ucsd.edu/mcauley_group/data/steam/australian_users_items.json.gz"

# Directory to store data
data_folder = "data"

# Ensure the data/ folder exists
os.makedirs(data_folder, exist_ok=True)

# Filenames for downloaded files
reviews_file_gz = os.path.join(data_folder, "australian_user_reviews.json.gz")
items_file_gz = os.path.join(data_folder, "australian_users_items.json.gz")

# Filenames for extracted files
reviews_file = os.path.join(data_folder, "australian_user_reviews.json")
items_file = os.path.join(data_folder, "australian_users_items.json")

def download_file(url, output_path):
    print(f"Downloading {url}...")
    response = requests.get(url, stream=True)
    if response.status_code == 200:
        with open(output_path, 'wb') as file:
            shutil.copyfileobj(response.raw, file)
        print(f"Downloaded {output_path}.")
    else:
        print(f"Failed to download {url}. Status code: {response.status_code}")

def extract_gz_file(input_path, output_path):
    print(f"Extracting {input_path}...")
    with gzip.open(input_path, 'rb') as gz_file:
        with open(output_path, 'wb') as out_file:
            shutil.copyfileobj(gz_file, out_file)
    print(f"Extracted {output_path}.")

# Download the files into the data/ folder
download_file(reviews_url, reviews_file_gz)
download_file(items_url, items_file_gz)

# Extract the files into the data/ folder
extract_gz_file(reviews_file_gz, reviews_file)
extract_gz_file(items_file_gz, items_file)



================================================
File: utils/import_data_neo4j.py
================================================
from neo4j import GraphDatabase
import csv
from tqdm import tqdm
from config import load_env  

class Neo4jimporter:
    def __init__(self, uri, user, password):
        self.driver = GraphDatabase.driver(uri, auth=(user, password))
        print(f"=== Connected as user : {user} ===")

        self.metrics = {
            "games_added": 0,
            "users_added": 0,
            "relationships_added": 0,
            "reviews_added": 0,
        }
    
    def close(self):
        self.driver.close()
    
    def create_constraints(self):
        """Ensure uniqueness of nodes by creating constraints on User and Game nodes."""
        with self.driver.session() as session:
            session.run("CREATE CONSTRAINT IF NOT EXISTS FOR (u:User) REQUIRE u.user_id IS UNIQUE;")
            session.run("CREATE CONSTRAINT IF NOT EXISTS FOR (g:Game) REQUIRE g.game_id IS UNIQUE;")

    def load_games(self, file_path):
        """
        Load game nodes from a CSV file. Each node will include attributes:
          - name: Name of the game.
          - time_played: Total hours played by all players.
          - player_count: Total number of players who played the game.
          - median_time_played: Median hours played by users.
          - max_bin_x: Hour bins indicating 20th percentiles.
        
        If a game node already exists (matched by game_id), the node is not recreated.
        """
        print("Loading games...")
        with self.driver.session() as session:
            with open(file_path, 'r', encoding='utf-8', errors='replace') as file: # file == "data_csv/games_data_bins.csv"
                csv_reader = csv.DictReader(file)
                total_games = count_rows(file_path)
                for row in tqdm(csv_reader, total=total_games, desc="Games Progress"):
                    session.run("""
                        MERGE (g:Game {game_id: $game_id})
                        ON CREATE SET g.name = $name,
                                      g.time_played = toInteger($time_played),
                                      g.player_count = toInteger($player_count),
                                      g.median_time_played = toInteger($median_time_played),
                                      g.max_bin_1 = toInteger($max_bin_1),
                                      g.max_bin_2 = toInteger($max_bin_2),
                                      g.max_bin_3 = toInteger($max_bin_3),
                                      g.max_bin_4 = toInteger($max_bin_4),
                                      g.max_bin_5 = toInteger($max_bin_5)
                    """, game_id=row['game_id'], name=row['name'],
                       time_played=row['time_played'], player_count=row['player_count'],
                       median_time_played=row['median_time_played'], max_bin_1=row['max_bin_1'],
                       max_bin_2=row['max_bin_2'], max_bin_3=row['max_bin_3'],
                       max_bin_4=row['max_bin_4'], max_bin_5=row['max_bin_5'])
                    self.metrics["games_added"] += 1

    def load_users(self, file_path):
        """
        Load user nodes from a CSV file. Each node will include attributes:
          - items_count: Number of items owned by the user.
          - played_games: Number of games played by the user.
          - total_playtime: Total playtime across all games.
          - most_played_game_id: ID of the game the user played the most.

        If a user node already exists (matched by user_id), the node is not recreated.
        """
        print("Loading users...")
        with self.driver.session() as session:
            with open(file_path, 'r', encoding='utf-8', errors='replace') as file:
                csv_reader = csv.DictReader(file)
                total_users = count_rows(file_path)
                for row in tqdm(csv_reader, total=total_users, desc="Users Progress"):
                    session.run("""
                        MERGE (u:User {user_id: $user_id})
                        ON CREATE SET u.items_count = toInteger($items_count),
                                      u.played_games = toInteger($played_games),
                                      u.total_playtime = toInteger($total_playtime),
                                      u.most_played_game_id = $most_played_game_id
                    """, user_id=row['user_id'], items_count=row['items_count'],
                       played_games=row['played_games'], total_playtime=row['total_playtime'],
                       most_played_game_id=row['most_played_game_id'])
                    self.metrics["users_added"] += 1

    def load_user_game_relationships(self, file_path):
        """
        Load relationships between users and games from a CSV file.
        Each relationship will include attributes:
          - playtime: Time spent by the user playing the game.
          - active: Indicates if the game is actively played.
        
        If a relationship already exists, it is not recreated.
        """
        print("Loading user-game relationships...")
        with self.driver.session() as session:
            with open(file_path, 'r', encoding='utf-8', errors='replace') as file:
                csv_reader = csv.DictReader(file)
                total_relationships = count_rows(file_path)
                for row in tqdm(csv_reader, total=total_relationships, desc="Relationships Progress"):
                    session.run("""
                        MERGE (u:User {user_id: $user_id})
                        MERGE (g:Game {game_id: $game_id})
                        MERGE (u)-[r:PLAYS]->(g)
                        ON CREATE SET r.playtime = toInteger($playtime),
                                    r.active = $active
                    """, user_id=row['user_id'], game_id=row['game_id'],
                    playtime=row['playtime'], active=row['active'])
                    self.metrics["relationships_added"] += 1

    def load_reviews(self, file_path):
        """
        Load reviews from a CSV file, establishing relationships between users and games.
        Each review relationship will include attributes:
          - funny: Indicates how funny other users find this review.
          - posted: Timestamp of when the review was posted.
          - last_edited: Timestamp of the last edit.
          - helpful: Indicates how helpful other users find this review.
          - recommend: Indicates whether the player recommends this game to others.
          - review: Text content of the review.
        
        If a review relationship already exists, it is not recreated.
        """
        print("Loading reviews...")
        with self.driver.session() as session:
            with open(file_path, 'r', encoding='utf-8', errors='replace') as file:
                csv_reader = csv.DictReader(file)
                total_reviews = count_rows(file_path)
                for row in tqdm(csv_reader, total=total_reviews, desc="Reviews Progress"):
                    session.run("""
                        MERGE (u:User {user_id: $user_id})
                        MERGE (g:Game {game_id: $item_id})
                        MERGE (u)-[r:REVIEWS {funny: $funny, posted: $posted, 
                                             last_edited: $last_edited, helpful: $helpful, 
                                             recommend: $recommend, review: $review}]->(g)
                    """, user_id=row['user_id'], item_id=row['item_id'],
                       funny=row['funny'], posted=row['posted'], last_edited=row['last_edited'],
                       helpful=row['helpful'], recommend=row['recommend'], review=row['review'])
                    self.metrics["reviews_added"] += 1
    
    def import_all_data(self, games_path, users_path, users_games_path, reviews_path):
        """
        Import all data into Neo4j by processing the provided CSV files:
          - Load games, users, user-game relationships, and reviews.
        """
        print("\n=== File Summary ===")
        print(f"Games file: {games_path}, Rows: {count_rows(games_path)}")
        print(f"Users file: {users_path}, Rows: {count_rows(users_path)}")
        print(f"User-Game Relationships file: {users_games_path}, Rows: {count_rows(users_games_path)}")
        print(f"Reviews file: {reviews_path}, Rows: {count_rows(reviews_path)}")
        print("=====================")

        self.create_constraints()
        self.load_games(games_path)
        self.load_users(users_path)
        self.load_user_game_relationships(users_games_path)
        self.load_reviews(reviews_path)

    def print_metrics(self):
        """Display a summary of the data imported into Neo4j."""
        print("\n=== Metrics Report ===")
        print(f"Games added: {self.metrics['games_added']}")
        print(f"Users added: {self.metrics['users_added']}")
        print(f"Relationships added: {self.metrics['relationships_added']}")
        print(f"Reviews added: {self.metrics['reviews_added']}")
        print("======================")

    def fetch_sample_data(self):
        """Retrieve and display 5 sample data from the Neo4j database"""
        with self.driver.session() as session:
            print("\n=== Sample Games ===")
            games = session.run("MATCH (g:Game) RETURN g.game_id AS game_id, g.name AS name LIMIT 5")
            for record in games:
                print(f"Game ID: {record['game_id']}, Name: {record['name']}")

            print("\n=== Sample Users ===")
            users = session.run("MATCH (u:User) RETURN u.user_id AS user_id LIMIT 5")
            for record in users:
                print(f"User ID: {record['user_id']}")

            print("\n=== Sample Reviews ===")
            reviews = session.run("""
                MATCH (u:User)-[r:REVIEWS]->(g:Game)
                RETURN u.user_id AS user_id, g.game_id AS game_id, r.review AS review LIMIT 5
            """)
            for record in reviews:
                print(f"User ID: {record['user_id']}, Game ID: {record['game_id']}, Review: {record['review']}")

def count_rows(file_path):
    """Count the number of rows in a CSV file (excluding the header)."""
    with open(file_path, 'r', encoding='utf-8', errors='replace') as file:
        return sum(1 for _ in file) - 1  # Subtract 1 for the header
    
if __name__ == "__main__":

    # Load environment variables
    env_config = load_env()
    DATABASE_URI = env_config["uri"]
    USERNAME = env_config["username"]
    PASSWORD = env_config["password"]
    
    # Define paths to the CSV files
    GAMES_FILE =  "data_csv/games_data_bins.csv"
    USER_GAME_FILE = "data_csv/users_games.csv"
    REVIEWS_FILE = "data_csv/aus_reviews.csv"
    USER_FILE = "data_csv/users_data.csv"

    print("Starting data imporing process...")

    # Initialize Neo4jimporer
    importer = Neo4jimporter(DATABASE_URI, USERNAME, PASSWORD)

    try:
        # Load all data into Neo4j
        importer.import_all_data(GAMES_FILE, USER_FILE, USER_GAME_FILE, REVIEWS_FILE)

        # Fetch and print sample data
        importer.fetch_sample_data()

        # Print metrics
        importer.print_metrics()

        print("Data successfully loaded into Neo4j!")
    except Exception as e:
        print(f"An error occurred: {e}")
    finally:
        importer.close()

    
    

================================================
File: utils/neo4j_recommender.py
================================================
from neo4j import GraphDatabase

class RecommenderSystem:
    def __init__(self, uri, user, password):
        """Initialize the connection to the Neo4j database."""
        self.driver = GraphDatabase.driver(uri, auth=(user, password))
    
    def close(self):
        """Close the connection to the Neo4j database."""
        self.driver.close()
    
    def collaborative_filtering(self, user_id, top_n=5):
        """
        Recommend games based on collaborative filtering.

        The query follows these steps:
        1. Match the target user and find games they have played.
        2. Identify similar users who have played the same games and count shared games.
        3. Sort similar users by the number of shared games.
        4. Limit the number of similar users (for performance).
        5. Find games played by similar users.
        6. Exclude games the target user already played.
        7. Return recommended games along with their popularity and names.
            - Popularity is calculated as the count of similar users who have played the recommended game.
        8. Sort by popularity and then alphabetically.
        9. Limit the number of recommendations.
        """
        query = """
        MATCH (target:User {user_id: $user_id})-[:PLAYS]->(g:Game)<-[:PLAYS]-(similar:User)
        WITH target, similar, COUNT(g) AS shared_games
        ORDER BY shared_games DESC
        LIMIT 10
        MATCH (similar)-[:PLAYS]->(recommended:Game)
        WHERE NOT (target)-[:PLAYS]->(recommended)  // Ensure 'target' is carried over from WITH
        RETURN recommended.game_id AS game_id, recommended.name AS name, COUNT(*) AS popularity
        ORDER BY popularity DESC, recommended.name
        LIMIT $top_n
        """
        with self.driver.session() as session:
            results = session.run(query, user_id=user_id, top_n=top_n)
            return [{"game_id": record["game_id"], "name": record["name"], "popularity": record["popularity"]} for record in results]
        
    def content_based_filtering(self, user_id, top_n=5):
        """Recommend games based on aggregated user preferences."""
        query = """
        MATCH (target:User {user_id: $user_id})-[:PLAYS]->(g:Game)
        WITH target, avg(g.median_time_played) AS user_avg_time, avg(g.player_count) AS user_avg_players
        MATCH (similar:Game)
        WHERE NOT (target)-[:PLAYS]->(similar)
        AND ABS(similar.median_time_played - user_avg_time) < 10
        AND ABS(similar.player_count - user_avg_players) < 100
        RETURN similar.game_id AS game_id, similar.name AS name,
            ABS(similar.median_time_played - user_avg_time) AS time_diff,
            ABS(similar.player_count - user_avg_players) AS player_diff
        ORDER BY time_diff, player_diff
        LIMIT $top_n
        """
        with self.driver.session() as session:
            results = session.run(query, user_id=user_id, top_n=top_n)
            return [{"game_id": record["game_id"], "name": record["name"],
                    "time_diff": record["time_diff"], "player_diff": record["player_diff"]} for record in results]

    
    def hybrid_recommendation(self, user_id, top_n=5):
        """Combine collaborative and content-based filtering with aggregated user preferences."""
        query = """
        MATCH (target:User {user_id: $user_id})-[:PLAYS]->(g:Game)
        WITH target, avg(g.median_time_played) AS user_avg_time, avg(g.player_count) AS user_avg_players
        MATCH (target)-[:PLAYS]->(g:Game)<-[:PLAYS]-(similar:User)
        WITH target, user_avg_time, user_avg_players, similar, COUNT(g) AS shared_games
        ORDER BY shared_games DESC
        LIMIT 10
        MATCH (similar)-[:PLAYS]->(recommended:Game)
        WHERE NOT (target)-[:PLAYS]->(recommended)
        AND ABS(recommended.median_time_played - user_avg_time) < 10
        AND ABS(recommended.player_count - user_avg_players) < 100
        RETURN recommended.game_id AS game_id, recommended.name AS name, 
            COUNT(*) AS popularity, 
            ABS(recommended.median_time_played - user_avg_time) AS time_diff, 
            ABS(recommended.player_count - user_avg_players) AS player_diff
        ORDER BY popularity DESC, time_diff ASC, player_diff ASC
        LIMIT $top_n
        """
        with self.driver.session() as session:
            results = session.run(query, user_id=user_id, top_n=top_n)
            return [
                {
                    "game_id": record["game_id"],
                    "name": record["name"],
                    "popularity": record["popularity"],
                    "time_diff": record["time_diff"],
                    "player_diff": record["player_diff"]
                }
                for record in results
            ]
    
    def recommend_by_bins(self, user_id, top_n=5):
        """TODO"""
        raise NotImplementedError("The 'recommend_by_bins' function is not implemented yet!")

    def list_users(self, limit=5):
        """List random users."""
        query = """
        MATCH (u:User)
        RETURN u.user_id AS user_id, u.items_count AS items_count
        ORDER BY rand()
        LIMIT $limit;
        """
        with self.driver.session() as session:
            results = session.run(query, limit=limit)
            return [{"user_id": record["user_id"], "items_count": record.get("items_count")} for record in results]

    def get_user_info(self, user_id):
        """
        Retrieve detailed information about a user and the games they played.
        Matches the user by ID, their played games, and any reviews they've written.
        Returns user stats and game details, ordered by playtime from most to least.  
        """
        query = """
        MATCH (u:User {user_id: $user_id})-[p:PLAYS]->(g:Game)
        OPTIONAL MATCH (u)-[r:REVIEWS]->(g)
        RETURN u.user_id AS user_id, 
            u.items_count AS items_count,
            u.played_games AS played_games, 
            u.total_playtime AS total_playtime,
            g.game_id AS game_id,
            g.name AS game_name,
            p.playtime AS playtime,
            g.max_bin_1 AS max_bin_1,
            g.max_bin_2 AS max_bin_2,
            g.max_bin_3 AS max_bin_3,
            g.max_bin_4 AS max_bin_4,
            g.max_bin_5 AS max_bin_5,
            g.player_count AS player_count,
            r.review AS review
        ORDER BY p.playtime DESC;
        """
        with self.driver.session() as session:
            results = session.run(query, user_id=user_id)
            user_info = None
            games = []

            for record in results:
                if not user_info:
                    user_info = {
                        "user_id": record["user_id"],
                        "items_count": record["items_count"],
                        "played_games": record["played_games"],
                        "total_playtime": record["total_playtime"],
                    }
                games.append({
                    "game_id": record["game_id"],
                    "name": record["game_name"],
                    "playtime": record["playtime"],  # Correctly fetch playtime from the PLAYS relationship
                    "max_bin": [record["max_bin_1"], record["max_bin_2"], record["max_bin_3"], record["max_bin_4"], record["max_bin_5"]],
                    "player_count": record["player_count"],
                    "review": record["review"]
                })

            # Add rank to each game
            for idx, game in enumerate(games, start=1):
                game["rank"] = idx

            if user_info:
                user_info["games"] = games

            return user_info


if __name__ == "__main__" : 

    from config import load_env  
    # Load environment variables
    env_config = load_env()
    DATABASE_URI = env_config["uri"]
    USERNAME = env_config["username"]
    PASSWORD = env_config["password"]

    # Initialize the recommender system
    recommender = RecommenderSystem(uri=DATABASE_URI, user=USERNAME, password=PASSWORD)

    try:
        user_id = "76561197970982479"  # Example user ID

        # Collaborative filtering recommendations
        print("Collaborative Filtering Recommendations:")
        collab_recommendations = recommender.collaborative_filtering(user_id)
        print(collab_recommendations)

        # Content-based filtering recommendations
        print("\nContent-Based Filtering Recommendations:")
        content_recommendations = recommender.content_based_filtering(user_id)
        print(content_recommendations)

        # Hybrid recommendations
        print("\nHybrid Recommendations:")
        hybrid_recommendations = recommender.hybrid_recommendation(user_id)
        print(hybrid_recommendations)

        # Recommendations using bins
        print("\nRecommendations Using Bins:")
        bin_recommendations = recommender.recommend_by_bins(user_id, bin_threshold=2)
        print(bin_recommendations)

    finally:
        recommender.close()


